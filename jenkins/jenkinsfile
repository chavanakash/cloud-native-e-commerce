pipeline {
    agent any

    environment {
        // Assume 'dockerizzz' is the host/name part of the registry (e.g., 'myregistry.com')
        DOCKER_REGISTRY = 'dockerizzz'
        DOCKER_CREDENTIALS = 'docker-hub-credentials'
        PATH = "/opt/homebrew/bin:${env.PATH}"
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    try {
                        if (!env.BUILD_NUMBER) {
                            env.BUILD_NUMBER = "0"
                        }
                        checkout([$class: 'GitSCM', 
                                 branches: [[name: '*/main']], 
                                 userRemoteConfigs: [[
                                     url: 'https://github.com/chavanakas/cloud-native-e-commerce.git',
                                     credentialsId: 'github-creds'
                                 ]]
                        ])
                        
                        env.GIT_COMMIT_SHORT = sh(
                            script: 'git rev-parse --short HEAD',
                            returnStdout: true
                        ).trim()

                    } catch (Exception e) {
                        echo "Git checkout failed: ${e.message}"
                        echo "Using local workspace instead"
                        env.GIT_COMMIT_SHORT = "local-${env.BUILD_NUMBER}"
                    }
                    echo "Building commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        stage('Install Backend Dependencies') {
            steps {
                script {
                    dir('backend') {
                        if (fileExists('package.json')) {
                            sh 'npm ci --prefer-offline --no-audit'
                        } else {
                            error('backend/package.json not found!')
                        }
                    }
                }
            }
        }
        
        stage('Install Frontend Dependencies') {
            steps {
                script {
                    dir('frontend') {
                        if (fileExists('package.json')) {
                            sh 'npm ci --prefer-offline --no-audit'
                        } else {
                            error('frontend/package.json not found!')
                        }
                    }
                }
            }
        }

        stage('Build Backend Image') {
            steps {
                script {
                    dir('backend') {
                        sh """
                            docker context use default || true
                            docker build -t ${env.DOCKER_REGISTRY}/countryside-backend:${env.GIT_COMMIT_SHORT} .
                            docker tag ${env.DOCKER_REGISTRY}/countryside-backend:${env.GIT_COMMIT_SHORT} ${env.DOCKER_REGISTRY}/countryside-backend:latest
                        """
                        echo "‚úÖ Backend image built successfully"
                    }
                }
            }
        }
        
        stage('Build Frontend Image') {
            steps {
                script {
                    dir('frontend') {
                        sh """
                            docker context use default || true
                            docker build -t ${env.DOCKER_REGISTRY}/countryside-frontend:${env.GIT_COMMIT_SHORT} .
                            docker tag ${env.DOCKER_REGISTRY}/countryside-frontend:${env.GIT_COMMIT_SHORT} ${env.DOCKER_REGISTRY}/countryside-frontend:latest
                        """
                        echo "‚úÖ Frontend image built successfully"
                    }
                }
            }
        }

        stage('Push Docker Images') {
            steps {
                script {
                    // FIX: Ensure correct registry URI is passed for authentication
                    docker.withRegistry("https://${env.DOCKER_REGISTRY}", env.DOCKER_CREDENTIALS) {
                        sh """
                            docker push ${env.DOCKER_REGISTRY}/countryside-backend:${env.GIT_COMMIT_SHORT}
                            docker push ${env.DOCKER_REGISTRY}/countryside-backend:latest
                            docker push ${env.DOCKER_REGISTRY}/countryside-frontend:${env.GIT_COMMIT_SHORT}
                            docker push ${env.DOCKER_REGISTRY}/countryside-frontend:latest
                        """
                        echo "‚úÖ Images pushed to Docker Hub successfully"
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo 'üöÄ Deploying to Kubernetes...'
                    
                    def minikubeStatus = sh(returnStatus: true, script: 'minikube status > /dev/null 2>&1')
                    
                    if (minikubeStatus != 0) {
                        echo "‚ö†Ô∏è Minikube is not running or not accessible. Starting Minikube..."
                        sh 'minikube start --memory=4096 --cpus=2'
                    }
                    
                    sh """
                        minikube kubectl -- apply -f k8s/mongodb-deployment.yaml
                        minikube kubectl -- apply -f k8s/backend-deployment.yaml
                        minikube kubectl -- apply -f k8s/frontend-deployment.yaml
                        
                        minikube kubectl -- set image deployment/backend-deployment \
                            backend=${env.DOCKER_REGISTRY}/countryside-backend:${env.GIT_COMMIT_SHORT}
                        
                        minikube kubectl -- set image deployment/frontend-deployment \
                            frontend=${env.DOCKER_REGISTRY}/countryside-frontend:${env.GIT_COMMIT_SHORT}
                        
                        echo "‚è≥ Waiting for deployments to complete..."
                        minikube kubectl -- rollout status deployment/backend-deployment --timeout=300s
                        minikube kubectl -- rollout status deployment/frontend-deployment --timeout=300s
                    """
                    
                    echo "‚úÖ Deployment completed successfully"
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    echo 'üîç Verifying deployment...'
                    sh """
                        echo "=== Pods ==="
                        minikube kubectl -- get pods
                        
                        echo "=== Services ==="
                        minikube kubectl -- get services
                        
                        echo "=== Ingress ==="
                        minikube kubectl -- get ingress || echo "No ingress found"
                        
                        echo "=== Deployment Status ==="
                        minikube kubectl -- get deployments
                    """
                    
                    def frontendUrl = sh(
                        script: 'minikube service frontend-service --url',
                        returnStdout: true
                    ).trim()
                    
                    echo "‚úÖ Application URL: ${frontendUrl}"
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo 'üßπ Cleaning up...'
                
                sh 'ls -la trivy-*.json || echo "No Trivy reports found"'
                archiveArtifacts artifacts: 'trivy-*.json', allowEmptyArchive: true
                
                sh 'docker system prune -af --volumes || true'
            }
        }
        success {
            script {
                echo '‚úÖ Pipeline executed successfully! ü•≥'
                echo '================================================'
                echo 'Deployment Information:'
                echo "- Backend Image: ${env.DOCKER_REGISTRY}/countryside-backend:${env.GIT_COMMIT_SHORT}"
                echo "- Frontend Image: ${env.DOCKER_REGISTRY}/countryside-frontend:${env.GIT_COMMIT_SHORT}"
                echo '================================================'
                
                try {
                    def appUrl = sh(
                        script: 'minikube service frontend-service --url',
                        returnStdout: true
                    ).trim()
                    echo "üåê Access your application at: ${appUrl}"
                } catch (Exception e) {
                    echo "Run: minikube service frontend-service --url to get the URL"
                }
            }
        }
        failure {
            echo '‚ùå Pipeline failed!'
            echo 'Check the logs above for details'
            
            script {
                try {
                    sh '''
                        echo "=== Backend Pod Logs ==="
                        minikube kubectl -- logs -l app=backend --tail=50 || true
                        
                        echo "=== Frontend Pod Logs ==="
                        minikube kubectl -- logs -l app=frontend --tail=50 || true
                    '''
                } catch (Exception e) {
                    echo "Could not retrieve pod logs: ${e.message}"
                }
            }
        }
        cleanup {
            echo 'üîÑ Performing workspace cleanup...'
            cleanWs()
        }
    }
}
